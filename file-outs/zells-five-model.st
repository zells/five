Object subclass: #Z5Dish	instanceVariableNames: 'events culture delays'	classVariableNames: ''	poolDictionaries: ''	category: 'zells-five-model'!!Z5Dish methodsFor: 'culture' stamp: 'NM 5/18/2017 14:46'!add: zell 	culture add: zell.	zell onEmit: [ :signal | self transmit: signal from: zell ].	events trigger: #zellAdded with: zell.	^ zell.! !!Z5Dish methodsFor: 'culture' stamp: 'NM 5/18/2017 16:13'!remove: zell 	culture remove: zell ifAbsent: [].	zell release.! !!Z5Dish methodsFor: 'signals' stamp: 'NM 5/18/2017 17:13'!transmit: signal from: emitter	culture do: [ :z | [			(Delay forSeconds: (self delayBetween: emitter and: z)) wait.			z receive: signal.	] fork ].! !!Z5Dish methodsFor: 'initialization' stamp: 'NM 5/18/2017 17:10'!initialize	events := Z5EventHandler new.	culture := Set new.	delays := Dictionary new.! !!Z5Dish methodsFor: 'events' stamp: 'NM 5/18/2017 14:39'!onZellAdded: block	events on: #zellAdded do: block.! !!Z5Dish methodsFor: 'delay' stamp: 'NM 5/18/2017 17:10'!delayBetween: emitter and: receiver 	^ delays at: (Set new add: emitter; add: receiver; yourself)		ifPresent: [ :d | ^ d ]		ifAbsent: [ ^ 0 ].! !!Z5Dish methodsFor: 'delay' stamp: 'NM 5/18/2017 18:32'!delayBetween: emitter and: receiver is: distance	delays at: (Set new add: emitter; add: receiver; yourself) put: distance.! !Object subclass: #Z5EventHandler	instanceVariableNames: 'listeners'	classVariableNames: ''	poolDictionaries: ''	category: 'zells-five-model'!!Z5EventHandler methodsFor: 'as yet unclassified' stamp: 'NM 5/18/2017 16:10'!clear	listeners removeAll.! !!Z5EventHandler methodsFor: 'as yet unclassified' stamp: 'NM 5/18/2017 14:36'!initialize	listeners := Dictionary new.! !!Z5EventHandler methodsFor: 'as yet unclassified' stamp: 'NM 5/18/2017 15:25'!on: event do: block	listeners at: event		ifPresent: [ :l | l add: block ]		ifAbsentPut: [ OrderedCollection new add: block; yourself ].! !!Z5EventHandler methodsFor: 'as yet unclassified' stamp: 'NM 5/18/2017 15:26'!trigger: event with: arg	listeners at: event ifPresent: [ :ls | ls do: [ :l | l value: arg ] ].! !Object subclass: #Z5Zell	instanceVariableNames: 'events'	classVariableNames: ''	poolDictionaries: ''	category: 'zells-five-model'!!Z5Zell methodsFor: 'events' stamp: 'NM 5/18/2017 21:52'!onAccept: block	events on: #accepted do: block.! !!Z5Zell methodsFor: 'events' stamp: 'NM 5/18/2017 14:44'!onEmit: block	events on: #emit do: block.! !!Z5Zell methodsFor: 'events' stamp: 'NM 5/18/2017 15:27'!onReceive: block	events on: #receive do: block.! !!Z5Zell methodsFor: 'events' stamp: 'NM 5/18/2017 16:09'!release	events clear.! !!Z5Zell methodsFor: 'dish' stamp: 'NM 5/18/2017 21:47'!accept: signal	events trigger: #accepted with: signal.! !!Z5Zell methodsFor: 'dish' stamp: 'NM 5/18/2017 14:44'!emit: signal	events trigger: #emit with: signal.! !!Z5Zell methodsFor: 'signals' stamp: 'NM 5/18/2017 21:49'!receive: signal	events trigger: #receive with: signal.! !!Z5Zell methodsFor: 'initialization' stamp: 'NM 5/18/2017 14:51'!initialize	events := Z5EventHandler new.! !Z5Zell subclass: #Z5ClockZell	instanceVariableNames: 'ticking signals frequency'	classVariableNames: ''	poolDictionaries: ''	category: 'zells-five-model'!!Z5ClockZell methodsFor: 'as yet unclassified' stamp: 'NM 6/24/2017 11:58'!addSignal: signal	signals add: signal.	events trigger: #changed with: self.! !!Z5ClockZell methodsFor: 'as yet unclassified' stamp: 'NM 6/24/2017 11:58'!clear	signals removeAll.	events trigger: #changed with: self.! !!Z5ClockZell methodsFor: 'as yet unclassified' stamp: 'NM 7/14/2017 15:59'!emitUnderstoodSignals	self emit: ((Z5StemZell named: 'understood signals')		haveA: (Z5StemZell named: 'start');		haveA: (Z5StemZell named: 'stop');		haveA: (Z5StemZell named: 'clear'))! !!Z5ClockZell methodsFor: 'as yet unclassified' stamp: 'NM 6/24/2017 11:57'!initialize	super initialize.	ticking  := false.	signals := OrderedCollection new.	frequency := 1.! !!Z5ClockZell methodsFor: 'as yet unclassified' stamp: 'NM 6/24/2017 11:57'!onChanged: block	events on: #changed do: block.! !!Z5ClockZell methodsFor: 'as yet unclassified' stamp: 'NM 7/14/2017 15:46'!receive: signal	super receive: signal.	(signal name = 'understood signals̀') ifTrue: [		self accept: signal.		self emitUnderstoodSignals].	((signal name = #start) and: ticking not) ifTrue: [		self accept: signal.		self start ].	(signal name = #stop) ifTrue: [		self accept: signal.		self stop ].	(signal name = #clear) ifTrue: [		self accept: signal.		self clear ].! !!Z5ClockZell methodsFor: 'as yet unclassified' stamp: 'NM 6/24/2017 12:00'!signals	^ signals.! !!Z5ClockZell methodsFor: 'as yet unclassified' stamp: 'NM 5/29/2017 11:28'!start	ticking := true.	[ [ ticking and: signals isEmpty not ] whileTrue: [ 		signals do: [ :s | self emit: s ].		(Delay forSeconds: 1 / frequency) wait.	] ] fork! !!Z5ClockZell methodsFor: 'as yet unclassified' stamp: 'NM 5/16/2017 12:20'!stop	ticking := false.! !Z5Zell subclass: #Z5DynamicZell	instanceVariableNames: 'behaviour'	classVariableNames: ''	poolDictionaries: ''	category: 'zells-five-model'!!Z5DynamicZell methodsFor: 'as yet unclassified' stamp: 'NM 5/18/2017 14:48'!behaviour: block 	behaviour := block.! !!Z5DynamicZell methodsFor: 'as yet unclassified' stamp: 'NM 5/18/2017 22:07'!receive: signal	super receive: signal.	behaviour ifNotNil: [ behaviour value: signal value: self ].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Z5DynamicZell class	instanceVariableNames: ''!!Z5DynamicZell class methodsFor: 'as yet unclassified' stamp: 'NM 5/18/2017 14:49'!doing: block	^ Z5DynamicZell new 		behaviour: block.! !Z5Zell subclass: #Z5StemZell	instanceVariableNames: 'name isA hasAs'	classVariableNames: ''	poolDictionaries: ''	category: 'zells-five-model'!!Z5StemZell methodsFor: 'as yet unclassified' stamp: 'NM 6/24/2017 12:28'!beA: aString	isA := aString.	events trigger: #beingA with: isA.! !!Z5StemZell methodsFor: 'as yet unclassified' stamp: 'NM 6/24/2017 22:50'!get: aName	self hasA: aName ifPresent: [:a|^ a]! !!Z5StemZell methodsFor: 'as yet unclassified' stamp: 'NM 6/24/2017 12:37'!hasA: aName ifAbsent: block	self hasA: aName ifPresent: [:a|] ifAbsent: block.! !!Z5StemZell methodsFor: 'as yet unclassified' stamp: 'NM 6/24/2017 12:48'!hasA: aName ifPresent: block	self hasA: aName ifPresent: block ifAbsent: [].! !!Z5StemZell methodsFor: 'as yet unclassified' stamp: 'NM 6/24/2017 12:38'!hasA: aName ifPresent: yesBlock ifAbsent: noBlock	hasAs do: [:a | a name = aName ifTrue: [yesBlock value: a. ^ nil]].	noBlock value.! !!Z5StemZell methodsFor: 'as yet unclassified' stamp: 'NM 6/23/2017 23:08'!hasAs	^ hasAs.! !!Z5StemZell methodsFor: 'as yet unclassified' stamp: 'NM 6/24/2017 10:19'!haveA: aStemZell	hasAs add: aStemZell.! !!Z5StemZell methodsFor: 'as yet unclassified' stamp: 'NM 6/23/2017 23:06'!initialize	super initialize.	hasAs := OrderedCollection new.! !!Z5StemZell methodsFor: 'as yet unclassified' stamp: 'NM 6/23/2017 22:55'!isA	^ isA! !!Z5StemZell methodsFor: 'as yet unclassified' stamp: 'NM 6/24/2017 10:19'!isA: aString	^ isA = aString.! !!Z5StemZell methodsFor: 'as yet unclassified' stamp: 'NM 6/23/2017 22:32'!name	^ name! !!Z5StemZell methodsFor: 'as yet unclassified' stamp: 'NM 6/23/2017 22:32'!name: aString	name := aString.! !!Z5StemZell methodsFor: 'as yet unclassified' stamp: 'NM 6/24/2017 12:26'!onBeingA: block	events on: #beingA do: block.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Z5StemZell class	instanceVariableNames: ''!!Z5StemZell class methodsFor: 'as yet unclassified' stamp: 'NM 6/23/2017 22:32'!named: aString	^ self new		name: aString;		yourself.! !!Z5StemZell class methodsFor: 'as yet unclassified' stamp: 'NM 6/24/2017 10:22'!named: aString thatIsA: bString	^ self new		name: aString;		beA: bString;		yourself.! !!Z5StemZell class methodsFor: 'as yet unclassified' stamp: 'NM 6/24/2017 10:22'!thatIsA: aString	^ self new		beA: aString;		yourself.! !Z5StemZell subclass: #Z5NumberZell	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'zells-five-model'!!Z5NumberZell methodsFor: 'as yet unclassified' stamp: 'NM 7/14/2017 15:57'!emitUnderstoodSignals	self emit: ((Z5StemZell named: 'understood signals')		haveA: (Z5StemZell new haveA: (Z5StemZell named: #target thatIsA: '"',self name,'"'); haveA: (Z5StemZell named: #be thatIsA: '1'));		haveA: (Z5StemZell new haveA: (Z5StemZell named: #target thatIsA: '"',self name,'"'); haveA: (Z5StemZell named: #increaseBy thatIsA: '1'));		haveA: (Z5StemZell new haveA: (Z5StemZell named: #target thatIsA: '"',self name,'"'); haveA: (Z5StemZell named: #add thatIsA: '4'); haveA: (Z5StemZell named: #tellResultTo thatIsA: '"bob"'))).! !!Z5NumberZell methodsFor: 'as yet unclassified' stamp: 'NM 6/24/2017 12:46'!initialize	super initialize.	self beA: '0'.! !!Z5NumberZell methodsFor: 'as yet unclassified' stamp: 'NM 7/14/2017 15:48'!receive: signal	super receive:signal.		(signal name = 'understood signals̀') ifTrue: [		self accept: signal.		self emitUnderstoodSignals].		signal hasA: #target 		ifPresent: [:a| (a isA: '"',self name,'"') ifFalse: [^ nil]] 		ifAbsent: [^ nil].			self accept:signal.		signal hasA: #be ifPresent: [:be|		self beA: be isA].	signal hasA: #increaseBy ifPresent: [:inc|		self beA: ((self isA asNumber) + (inc isA asNumber) roundTo: 0.01) asString].	signal hasA: #tellValueTo ifPresent: [:to|		self emit: (Z5StemZell new 			haveA: (Z5StemZell named: #target thatIsA: to isA);			haveA: (Z5StemZell named: #value thatIsA: self isA))].	signal hasA: #add ifPresent: [:add|		self emit: (Z5StemZell new			haveA: (Z5StemZell named: #target thatIsA: ((signal get: #tellResultTo) isA));			haveA: (Z5StemZell named: #result thatIsA: ((self isA asNumber) + (add isA asNumber) rounded) asString))].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Z5NumberZell class	instanceVariableNames: ''!!Z5NumberZell class methodsFor: 'as yet unclassified' stamp: 'NM 5/25/2017 13:54'!named: name	 ^ (self new) 		name: name; 		yourself! !Z5Zell subclass: #Z5TurtleZell	instanceVariableNames: 'observers position heading path speed running'	classVariableNames: ''	poolDictionaries: ''	category: 'zells-five-model'!!Z5TurtleZell methodsFor: 'as yet unclassified' stamp: 'NM 7/14/2017 15:59'!emitUnderstoodSignals	self emit: ((Z5StemZell named: 'understood signals')		haveA: (Z5StemZell named: 'go');		haveA: (Z5StemZell named: 'go' thatIsA: '50');		haveA: (Z5StemZell named: 'turn');		haveA: (Z5StemZell named: 'turn' thatIsA: '90');		haveA: (Z5StemZell named: 'reset')).! !!Z5TurtleZell methodsFor: 'as yet unclassified' stamp: 'NM 5/25/2017 22:51'!go: distance	| update |	update := [:s :i|		position := s + (i@0 rotateBy: heading degreesToRadians about: 0@0).		path at: (path size) put: position].		path add:position.	self run: update from: position by: distance with: speed.! !!Z5TurtleZell methodsFor: 'as yet unclassified' stamp: 'NM 5/15/2017 22:56'!heading	^ heading! !!Z5TurtleZell methodsFor: 'as yet unclassified' stamp: 'NM 5/15/2017 22:57'!informObservers	observers do: [ :o | o changed ]! !!Z5TurtleZell methodsFor: 'as yet unclassified' stamp: 'NM 5/18/2017 20:23'!initialize	super initialize.	running := false.	speed := 2.	observers := Set new.		self reset.! !!Z5TurtleZell methodsFor: 'as yet unclassified' stamp: 'NM 5/15/2017 20:44'!observedBy: anObserver	observers add: anObserver.! !!Z5TurtleZell methodsFor: 'as yet unclassified' stamp: 'NM 5/15/2017 22:56'!path	^ path! !!Z5TurtleZell methodsFor: 'as yet unclassified' stamp: 'NM 5/15/2017 22:56'!position	^ position! !!Z5TurtleZell methodsFor: 'as yet unclassified' stamp: 'NM 7/14/2017 15:40'!receive: signal	super receive: signal.	(signal name = 'understood signals̀') ifTrue: [		self accept: signal.		self emitUnderstoodSignals].	(signal name = #stop) ifTrue: [		self accept: signal.		self stop].	(signal name = #reset) ifTrue: [		self accept: signal.		self reset ].	(signal name = #turn) ifTrue: [		self accept: signal.		self turn: (signal isA ifNil: [15] ifNotNil: [signal isA asNumber]).].	(signal name = #go) ifTrue: [		self accept: signal.				signal isA 			ifNil: [self go: 10];			ifNotNil: [					signal isA asInteger isNil					ifTrue: [						self emit: (Z5StemZell new 							haveA: (Z5StemZell named: #target thatIsA: '"distance"'); 							haveA: (Z5StemZell named: #tellValueTo thatIsA: '"goValue"'))]					ifFalse: [self go: signal isA asNumber]]].					(signal hasA: #target ifPresent: [:a|		(a isA: '"goValue"') ifTrue: [			signal hasA: #value ifPresent: [:v|				self accept: signal.				self go: v isA asNumber]]])! !!Z5TurtleZell methodsFor: 'as yet unclassified' stamp: 'NM 5/25/2017 22:58'!reset	self stop.	position := 100@150.	heading := 90.	path := OrderedCollection new.	path add: position.	self informObservers! !!Z5TurtleZell methodsFor: 'as yet unclassified' stamp: 'NM 5/25/2017 23:08'!run: update from: start by: delta with: speed	| step steps |	steps := delta / speed.		step := 0.	running := true.	 [		[ step := step + 1. running and: step <= steps ] whileTrue: [			update value: start value: step * speed.			self informObservers.			(Delay forMilliseconds: 100) wait ].				running ifTrue: [					update value: start value: delta.			self informObservers].	] fork! !!Z5TurtleZell methodsFor: 'as yet unclassified' stamp: 'NM 5/25/2017 22:56'!stop	running := false.! !!Z5TurtleZell methodsFor: 'as yet unclassified' stamp: 'NM 5/25/2017 22:56'!turn: degrees	| update |	update := [:start :increment|		heading := start + increment].		self run: update from: heading by: degrees with: speed*2.! !